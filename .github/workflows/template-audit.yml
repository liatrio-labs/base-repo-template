name: Template Audit

on:
  schedule:
    - cron: '0 0 1 * *' # Run on the 1st of every month at midnight UTC
  workflow_dispatch:
    inputs:
      target_repository:
        description: 'Target repository to audit (format: GitHub URL, org/repo, or absolute local path)'
        required: true
        type: string
      template_repository:
        description: 'Template repository to use as baseline (default: liatrio-labs/open-source-project-template)'
        required: false
        type: string
        default: 'liatrio-labs/open-source-project-template'

jobs:
  audit:
    timeout-minutes: 30
    runs-on: ubuntu-latest
    outputs:
      report_path: ${{ steps.audit.outputs.report_path }}
    permissions:
      contents: read
      pull-requests: write
      issues: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Install Cursor CLI
        run: |
          curl https://cursor.sh/install.sh | bash
          echo "$HOME/.cursor/bin" >> $GITHUB_PATH

      - name: Run template audit with Cursor Agent
        id: audit
        env:
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
          TARGET_REPOSITORY: ${{ github.event.inputs.target_repository || github.repository }}
          TEMPLATE_REPOSITORY: ${{ github.event.inputs.template_repository || 'liatrio-labs/open-source-project-template' }}
        run: |
          PROMPT_FILE="prompts/repository-template-audit.md"
          COMBINED_FILE=".github/template-audit-instructions.md"
          REPORT_FILE="audit-report.md"

          # Verify prompt file exists
          if [ ! -f "$PROMPT_FILE" ]; then
            echo "Error: Prompt file '$PROMPT_FILE' not found"
            exit 1
          fi

          # Create combined file with arguments at top, then full prompt content
          cat > "$COMBINED_FILE" << EOF
          Target repository: ${TARGET_REPOSITORY}
          Template repository: ${TEMPLATE_REPOSITORY}

          $(cat "$PROMPT_FILE")
          EOF

          # Invoke cursor-agent with simple prompt referencing the combined file
          # Capture stdout/stderr as backup (cursor-agent should write file per prompt instructions)
          # If cursor-agent writes the file directly, this backup ensures we don't lose output
          cursor-agent -p "Follow the instructions in $COMBINED_FILE" --model composer-1 > "$REPORT_FILE" 2>&1 || {
            EXIT_CODE=$?
            echo "cursor-agent exited with code $EXIT_CODE"
            # If file doesn't exist but we have stdout, that's okay
            if [ ! -f "$REPORT_FILE" ] || [ ! -s "$REPORT_FILE" ]; then
              echo "Error: cursor-agent failed and no report was generated"
              exit $EXIT_CODE
            fi
          }

          # Verify report file was created and has content
          if [ ! -f "$REPORT_FILE" ] || [ ! -s "$REPORT_FILE" ]; then
            echo "Error: Report file '$REPORT_FILE' is missing or empty"
            echo "Cursor agent may not have written the report to the file as instructed"
            exit 1
          fi

          # Set report path as output
          echo "report_path=$REPORT_FILE" >> $GITHUB_OUTPUT

          # Add report to job summary
          echo "## ðŸ“‹ Template Audit Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Target Repository:** ${TARGET_REPOSITORY}" >> $GITHUB_STEP_SUMMARY
          echo "**Template Baseline:** ${TEMPLATE_REPOSITORY}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -f "$REPORT_FILE" ]; then
            cat "$REPORT_FILE" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ Report file not found. Check workflow logs for cursor-agent output." >> $GITHUB_STEP_SUMMARY
          fi
